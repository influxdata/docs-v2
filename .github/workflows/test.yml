name: Test Code Blocks

on:
  pull_request:
    paths:
      - 'content/**/*.md'
      - 'test/**'
      - 'Dockerfile.pytest'
      - 'compose.yaml'
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      products:
        description: 'Products to test (comma-separated: core,enterprise,telegraf,v2,cloud,cloud-dedicated,cloud-serverless,clustered)'
        required: false
        default: ''
      use_default_group:
        description: 'Use default group (core + telegraf) if no products specified'
        type: boolean
        required: false
        default: true

# Product to test script mapping
# Products that run automatically in CI (on PR):
#   - core (influxdb3_core) â†’ influxdb3-core-pytest
#   - telegraf â†’ telegraf-pytest
#   - v2 â†’ v2-pytest
# Products available for manual dispatch only:
#   - cloud â†’ cloud-pytest
#   - cloud-dedicated â†’ cloud-dedicated-pytest
#   - cloud-serverless â†’ cloud-serverless-pytest
#   - clustered â†’ clustered-pytest
# Products without pytest services (content paths only):
#   - enterprise â†’ content/influxdb3/enterprise
#   - v1 â†’ content/influxdb/v1
#   - explorer â†’ content/influxdb3/explorer

jobs:
  detect-changes:
    name: Detect test requirements
    runs-on: ubuntu-latest
    outputs:
      should-run: ${{ steps.check.outputs.should-run }}
      test-products: ${{ steps.check.outputs.test-products }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if tests should run
        id: check
        run: |
          # Default product group: core + telegraf
          DEFAULT_PRODUCTS=("influxdb3_core" "telegraf")

          # For workflow_dispatch, use specified products or default
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT

            INPUT_PRODUCTS="${{ github.event.inputs.products }}"
            USE_DEFAULT="${{ github.event.inputs.use_default_group }}"

            if [[ -n "$INPUT_PRODUCTS" ]]; then
              # Parse comma-separated products and normalize names
              PRODUCTS=()
              IFS=',' read -ra PRODUCT_LIST <<< "$INPUT_PRODUCTS"
              for product in "${PRODUCT_LIST[@]}"; do
                # Trim whitespace and normalize product names
                product=$(echo "$product" | xargs)
                case "$product" in
                  core|influxdb3_core|influxdb3-core)
                    PRODUCTS+=("influxdb3_core")
                    ;;
                  enterprise|influxdb3_enterprise|influxdb3-enterprise)
                    PRODUCTS+=("influxdb3_enterprise")
                    ;;
                  telegraf)
                    PRODUCTS+=("telegraf")
                    ;;
                  v2|influxdb_v2)
                    PRODUCTS+=("v2")
                    ;;
                  v1|influxdb_v1)
                    PRODUCTS+=("v1")
                    ;;
                  cloud|influxdb_cloud)
                    PRODUCTS+=("cloud")
                    ;;
                  cloud-dedicated|cloud_dedicated)
                    PRODUCTS+=("cloud-dedicated")
                    ;;
                  cloud-serverless|cloud_serverless)
                    PRODUCTS+=("cloud-serverless")
                    ;;
                  clustered)
                    PRODUCTS+=("clustered")
                    ;;
                  explorer|influxdb3_explorer)
                    PRODUCTS+=("explorer")
                    ;;
                  *)
                    echo "âš ï¸ Unknown product: $product (skipping)"
                    ;;
                esac
              done
            elif [[ "$USE_DEFAULT" == "true" ]]; then
              PRODUCTS=("${DEFAULT_PRODUCTS[@]}")
              echo "ðŸ“¦ Using default product group: ${PRODUCTS[*]}"
            else
              echo "âŒ No products specified and default group disabled"
              echo "should-run=false" >> $GITHUB_OUTPUT
              exit 0
            fi

            # Convert to JSON array
            PRODUCTS_JSON=$(printf '%s\n' "${PRODUCTS[@]}" | jq -R . | jq -s -c .)
            echo "test-products=$PRODUCTS_JSON" >> $GITHUB_OUTPUT
            echo "âœ… Will run tests for: ${PRODUCTS[*]}"
            exit 0
          fi

          # For PRs, check if content files changed
          CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }}...${{ github.sha }} | grep '^content/.*\.md$' || true)

          if [[ -z "$CHANGED_FILES" ]]; then
            echo "should-run=false" >> $GITHUB_OUTPUT
            echo "ðŸ“ No content changes detected - skipping code block tests"
            exit 0
          fi

          echo "should-run=true" >> $GITHUB_OUTPUT

          # Determine which product tests to run based on changed files
          # Note: cloud, cloud-dedicated, cloud-serverless, and clustered are excluded
          # from automatic CI runs. Use manual workflow_dispatch to test these products.
          PRODUCTS=()

          # InfluxDB 3 products (automatic CI)
          if echo "$CHANGED_FILES" | grep -q '^content/influxdb3/core/'; then
            PRODUCTS+=("influxdb3_core")
          fi

          if echo "$CHANGED_FILES" | grep -q '^content/influxdb3/enterprise/'; then
            PRODUCTS+=("influxdb3_enterprise")
          fi

          if echo "$CHANGED_FILES" | grep -q '^content/influxdb3/explorer/'; then
            PRODUCTS+=("explorer")
          fi

          # InfluxDB v1/v2 products (automatic CI - v2 only)
          if echo "$CHANGED_FILES" | grep -q '^content/influxdb/v2/'; then
            PRODUCTS+=("v2")
          fi

          if echo "$CHANGED_FILES" | grep -q '^content/influxdb/v1/'; then
            PRODUCTS+=("v1")
          fi

          # Telegraf (automatic CI)
          if echo "$CHANGED_FILES" | grep -q '^content/telegraf/'; then
            PRODUCTS+=("telegraf")
          fi

          # Log excluded products if their content changed (for visibility)
          if echo "$CHANGED_FILES" | grep -q '^content/influxdb3/cloud-dedicated/'; then
            echo "â„¹ï¸ cloud-dedicated content changed - excluded from automatic CI (use manual dispatch)"
          fi
          if echo "$CHANGED_FILES" | grep -q '^content/influxdb3/cloud-serverless/'; then
            echo "â„¹ï¸ cloud-serverless content changed - excluded from automatic CI (use manual dispatch)"
          fi
          if echo "$CHANGED_FILES" | grep -q '^content/influxdb3/clustered/'; then
            echo "â„¹ï¸ clustered content changed - excluded from automatic CI (use manual dispatch)"
          fi
          if echo "$CHANGED_FILES" | grep -q '^content/influxdb/cloud/'; then
            echo "â„¹ï¸ cloud content changed - excluded from automatic CI (use manual dispatch)"
          fi

          # If shared content changed, use default group (core + telegraf)
          if echo "$CHANGED_FILES" | grep -q '^content/shared/'; then
            echo "ðŸ“ Shared content changed - adding default products"
            for default_product in "${DEFAULT_PRODUCTS[@]}"; do
              if [[ ! " ${PRODUCTS[*]} " =~ " ${default_product} " ]]; then
                PRODUCTS+=("$default_product")
              fi
            done
          fi

          # If no specific products matched, use default group
          if [[ ${#PRODUCTS[@]} -eq 0 ]]; then
            echo "ðŸ“¦ No specific products detected - using default group"
            PRODUCTS=("${DEFAULT_PRODUCTS[@]}")
          fi

          # Convert to JSON array
          PRODUCTS_JSON=$(printf '%s\n' "${PRODUCTS[@]}" | jq -R . | jq -s -c .)
          echo "test-products=$PRODUCTS_JSON" >> $GITHUB_OUTPUT

          echo "âœ… Will run tests for: ${PRODUCTS[*]}"

  test-codeblocks:
    name: Test ${{ matrix.product }} code blocks
    needs: detect-changes
    if: needs.detect-changes.outputs.should-run == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30

    strategy:
      fail-fast: false
      matrix:
        product: ${{ fromJson(needs.detect-changes.outputs.test-products) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: |
          # Skip Cypress installation to speed up CI
          CYPRESS_INSTALL_BINARY=0 yarn install --frozen-lockfile

      - name: Build pytest Docker image
        run: |
          echo "Building influxdata/docs-pytest image..."
          docker build -t influxdata/docs-pytest:latest -f Dockerfile.pytest .

      - name: Setup test credentials (mock)
        run: |
          # Create mock .env.test files for CI
          # In production, these would be configured with actual credentials

          # InfluxDB 3 products
          mkdir -p content/influxdb3/core
          mkdir -p content/influxdb3/enterprise
          mkdir -p content/influxdb3/cloud-dedicated
          mkdir -p content/influxdb3/cloud-serverless
          mkdir -p content/influxdb3/clustered

          # InfluxDB v1/v2 products
          mkdir -p content/influxdb/cloud
          mkdir -p content/influxdb/v2
          mkdir -p content/influxdb/v1

          # Telegraf
          mkdir -p content/telegraf/v1

          # InfluxDB 3 Core
          cat > content/influxdb3/core/.env.test << 'EOF'
          # Mock credentials for CI testing
          INFLUX_HOST=http://localhost:8282
          INFLUX_TOKEN=mock_token_for_ci
          INFLUX_DATABASE=test_db
          EOF

          # InfluxDB 3 Enterprise
          cat > content/influxdb3/enterprise/.env.test << 'EOF'
          # Mock credentials for CI testing
          INFLUX_HOST=http://localhost:8181
          INFLUX_TOKEN=mock_token_for_ci
          INFLUX_DATABASE=test_db
          EOF

          # InfluxDB 3 Cloud products
          for product in cloud-dedicated cloud-serverless clustered; do
            cat > content/influxdb3/$product/.env.test << 'EOF'
          # Mock credentials for CI testing
          INFLUX_HOST=https://cluster.influxdata.com
          INFLUX_TOKEN=mock_token_for_ci
          INFLUX_DATABASE=test_db
          ACCOUNT_ID=mock_account
          CLUSTER_ID=mock_cluster
          EOF
          done

          # InfluxDB Cloud (v2)
          cat > content/influxdb/cloud/.env.test << 'EOF'
          # Mock credentials for CI testing
          INFLUX_HOST=https://cloud2.influxdata.com
          INFLUX_TOKEN=mock_token_for_ci
          INFLUX_ORG=mock_org
          INFLUX_BUCKET=mock_bucket
          EOF

          # InfluxDB v2
          cat > content/influxdb/v2/.env.test << 'EOF'
          # Mock credentials for CI testing
          INFLUX_HOST=http://localhost:8086
          INFLUX_TOKEN=mock_token_for_ci
          INFLUX_ORG=mock_org
          INFLUX_BUCKET=mock_bucket
          EOF

          # InfluxDB v1
          cat > content/influxdb/v1/.env.test << 'EOF'
          # Mock credentials for CI testing
          INFLUX_HOST=http://localhost:8086
          INFLUX_USERNAME=mock_user
          INFLUX_PASSWORD=mock_password
          EOF

          # Telegraf
          cat > content/telegraf/v1/.env.test << 'EOF'
          # Mock credentials for CI testing
          INFLUX_HOST=https://cloud2.influxdata.com
          INFLUX_TOKEN=mock_token_for_ci
          EOF

          echo "âœ… Mock test credentials created"

      - name: Run ${{ matrix.product }} code block tests
        id: test
        continue-on-error: true
        run: |
          echo "Running tests for ${{ matrix.product }}..."

          # Map product names to yarn test commands
          # Some products don't have pytest services yet - skip them gracefully
          case "${{ matrix.product }}" in
            influxdb3_core)
              TEST_CMD="yarn test:codeblocks:influxdb3_core"
              ;;
            influxdb3_enterprise)
              echo "âš ï¸ InfluxDB 3 Enterprise tests not yet configured - skipping"
              echo "test-status=skipped" >> $GITHUB_OUTPUT
              echo "exit-code=0" >> $GITHUB_OUTPUT
              exit 0
              ;;
            telegraf)
              TEST_CMD="yarn test:codeblocks:telegraf"
              ;;
            v2)
              TEST_CMD="yarn test:codeblocks:v2"
              ;;
            v1)
              echo "âš ï¸ InfluxDB v1 tests not yet configured - skipping"
              echo "test-status=skipped" >> $GITHUB_OUTPUT
              echo "exit-code=0" >> $GITHUB_OUTPUT
              exit 0
              ;;
            cloud)
              TEST_CMD="yarn test:codeblocks:cloud"
              ;;
            cloud-dedicated)
              TEST_CMD="yarn test:codeblocks:cloud-dedicated"
              ;;
            cloud-serverless)
              TEST_CMD="yarn test:codeblocks:cloud-serverless"
              ;;
            clustered)
              TEST_CMD="yarn test:codeblocks:clustered"
              ;;
            explorer)
              echo "âš ï¸ InfluxDB 3 Explorer tests not yet configured - skipping"
              echo "test-status=skipped" >> $GITHUB_OUTPUT
              echo "exit-code=0" >> $GITHUB_OUTPUT
              exit 0
              ;;
            *)
              echo "âŒ Unknown product: ${{ matrix.product }}"
              echo "test-status=failed" >> $GITHUB_OUTPUT
              echo "exit-code=1" >> $GITHUB_OUTPUT
              exit 1
              ;;
          esac

          # Run the test command
          $TEST_CMD || EXIT_CODE=$?

          # Capture exit code for reporting
          if [[ -n "$EXIT_CODE" ]]; then
            echo "test-status=failed" >> $GITHUB_OUTPUT
            echo "exit-code=$EXIT_CODE" >> $GITHUB_OUTPUT
          else
            echo "test-status=passed" >> $GITHUB_OUTPUT
            echo "exit-code=0" >> $GITHUB_OUTPUT
          fi

      - name: Generate test summary
        if: always()
        run: |
          STATUS="${{ steps.test.outputs.test-status }}"
          case "$STATUS" in
            passed)
              STATUS_ICON="âœ… Passed"
              ;;
            skipped)
              STATUS_ICON="â­ï¸ Skipped"
              ;;
            *)
              STATUS_ICON="âŒ Failed"
              ;;
          esac

          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## Code Block Test Results - ${{ matrix.product }}

          **Status:** $STATUS_ICON
          **Product:** ${{ matrix.product }}
          **Exit Code:** ${{ steps.test.outputs.exit-code }}

          EOF

          if [[ "$STATUS" == "failed" ]]; then
            cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          âš ï¸ **Note:** Code block tests require valid credentials configured in `.env.test` files.
          In CI, mock credentials are used which may cause some tests to fail.
          Review the test output above for specific failures.

          To test locally with real credentials:
          1. Create `.env.test` files in product directories
          2. Run `yarn test:codeblocks:<product>`
          EOF
          elif [[ "$STATUS" == "skipped" ]]; then
            cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          â„¹ï¸ **Note:** This product does not have a pytest service configured yet.
          To add testing support, create a Docker Compose service in `compose.yaml`.
          EOF
          fi

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.product }}
          path: |
            test/shared/**
            pytest-*.log
          retention-days: 7
          if-no-files-found: ignore

      - name: Fail job if tests failed
        if: steps.test.outputs.test-status == 'failed'
        run: |
          echo "::error::Code block tests failed for ${{ matrix.product }}"
          exit 1

      - name: Report skipped tests
        if: steps.test.outputs.test-status == 'skipped'
        run: |
          echo "::notice::Tests skipped for ${{ matrix.product }} - pytest service not configured"

  test-summary:
    name: Code Block Test Summary
    needs: [detect-changes, test-codeblocks]
    if: always() && needs.detect-changes.outputs.should-run == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Check test results
        run: |
          # This job will fail if any of the test jobs failed
          if [[ "${{ needs.test-codeblocks.result }}" == "failure" ]]; then
            echo "::error::One or more code block test suites failed"
            exit 1
          elif [[ "${{ needs.test-codeblocks.result }}" == "success" ]]; then
            echo "âœ… All code block tests passed"
          else
            echo "âš ï¸ Tests were skipped or cancelled"
          fi
